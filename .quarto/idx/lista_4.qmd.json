{"title":"Lista 4 - GMM e ICC","markdown":{"headingText":"Lista 4 - GMM e ICC","containsRefs":false,"markdown":"\nPara resolver a lista de exercícios 4 vamos utilizar o [banco de dados THKS2](https://drive.google.com/file/d/1GVse4Sq6B66Cs9qeyA5BJwv2SxgYrip-/view?usp=sharing). O banco apresenta dados do programa \"Television, School and Family Smoking Prevention and Cessation Project (TVSFP)\", que avaliou a eficácia de um programa presencial para parar de fumar (Currículo) em conjunto com um programa em vídeo (TV) para prevenir o início do tabagismo e fortalecer a resiliência daqueles que deixaram de fumar.\n\nO estudo adotou um delineamento 2x2 com quatro grupos distintos, considerando a presença do \"school-based social-resistance curriculum (CC)\" e do \"television-based prevention program (TV)\". Esses grupos foram categorizados como \"Curriculum & TV\", \"Curriculum\", \"TV\" e \"Neither\". Este último indicando que as pessoas do grupo não participaram de nenhuma intervenção.\n\nA randomização da amostra ocorreu em dois níveis: por escolas e por salas de aula. O banco de dados inclui informações de 1600 alunos de 135 classes distintas em 28 escolas localizadas em Los Angeles. A variável dependente, a Escala de Conhecimento em Tabaco e Saúde (THKS), foi avaliada antes da randomização e após a implementação dos efeitos de cada grupo.\n\nCom base nestes dados, por favor, apresente as questões específicas e descreva os resultados utilizando as notações apropriadas.\n\n## Pacotes que vamos utilizar\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n\n# Seu código R aqui\nlibrary(emmeans)\nlibrary(lme4)\nlibrary(nlme)\nlibrary(flexplot)\nlibrary(foreign)\nlibrary(dplyr)\nlibrary(multcomp)\nlibrary(effects)\nlibrary(sjstats)\nlibrary(tm)\nlibrary(report)\nlibrary(ggplot2)\nlibrary(forcats)\nlibrary(performance)\nlibrary(rempsyc)\nlibrary(easystats)\nlibrary(fitdistrplus)\nlibrary(sjPlot)\nlibrary(kableExtra)\nlibrary(psychometric)\nlibrary(misty)\n```\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n\ndataset = read.spss(\"THKS2.sav\", to.data.frame=TRUE)\n```\n\nComo já mencionado no capítulo anterior, é muito importante averiguar os tipos de variáveis antes de começar as análises. Para isso vamos utilizar a função `glimpse()`.\n\n```{r}\nglimpse(dataset)\n```\n\nAo analisar os arquivos provenientes de outros programas, percebe-se que todas as variáveis numéricas são tratadas como contínuas. No entanto, todas as variáveis no banco de dados são, na verdade, categóricas. Portanto, é necessário modificar o tipo das variáveis antes de iniciar as análises. Para isso vamos utilizar a função `as.factor()` nas 4 variáveis contínuas.\n\n```{r}\ndataset$SchoolID = as.factor(dataset$SchoolID)\ndataset$ClassID = as.factor(dataset$ClassID)\ndataset$PreTHKS = as.integer(dataset$PreTHKS)\ndataset$PosTHKS = as.integer(dataset$PosTHKS)\n\n```\n\nRodando novamente a função `glimpse()` podemos verificar se a mudança aconteceu.\n\n```{r}\nglimpse(dataset)\n```\n\nPodemos também calcular o número de alunos por classe também. Isso será bem útil para uma análise Extra no fim do capítulo.\n\n```{r}\ndataset$Tamanho_Classe <- ave(dataset$PreTHKS, dataset$SchoolID, dataset$ClassID, FUN = length)\n\n```\n\n## a) Modelos hierárquicos\n\n::: callout-note\n#### Exercício\n\nCom base no desenho apresentado, qual é a pergunta que este estudo quer responder?\n:::\n\nPara abordar as questões específicas relacionadas ao banco de dados THKS2 utilizando um modelo linear GMM hierárquico, precisamos formular perguntas específicas que desejamos responder com a análise. Dado que o THKS é a variável dependente e foi avaliado antes e depois da implementação dos diferentes grupos de intervenção, podemos considerar algumas perguntas relevantes:\n\n-   Efeito geral da intervenção: Como a média da escala THKS varia entre os grupos \"Curriculum & TV\", \"Curriculum\", \"TV\" e \"Neither\" após a implementação das intervenções?\n\n-   Diferenças entre grupos específicos: Há diferenças significativas nas mudanças médias da escala THKS entre os grupos \"Curriculum & TV\", \"Curriculum\", \"TV\" e \"Neither\"?\n\n-   Variação entre escolas e salas de aula: A variação nas médias da escala THKS é significativa entre as escolas ou entre as salas de aula, considerando o efeito das intervenções?\n\nA análise gráfica pode ser fundamental para avaliar a validade da escolha de um modelo hierárquico. Ao comparar as médias do PreTHKS e do PosTHKS para diferentes escolas e salas de aula, os gráficos podem revelar padrões ou tendências que indicam se há variação sistemática ou não nas médias entre esses níveis hierárquicos. A identificação de padrões específicos pode orientar a decisão de usar um modelo hierárquico para capturar a estrutura aninhada dos dados.\n\nVamos criar um gráfico das médias de THKS entre as escolas antes e depois das intervenções.\n\n### Média por Escola\n\n```{r}\n# Instale o pacote ggplot2 se ainda não o tiver instalado\n# install.packages(\"ggplot2\")\n\n\n# Crie um novo dataframe para armazenar a média das notas por escola\nmedia_por_escola <- aggregate(cbind(PosTHKS, PreTHKS) ~ SchoolID, data = dataset, FUN = mean)\n\n# Transforme os dados em formato longo (tidy)\nmedia_por_escola_long <- tidyr::pivot_longer(media_por_escola, cols = c(\"PreTHKS\", \"PosTHKS\"), names_to = \"tempo\", values_to = \"media\")\n\n# Crie um gráfico de dispersão com uma linha contínua conectando as médias das notas\nggplot(data = media_por_escola_long, aes(x = forcats::fct_rev(tempo), y = media, color = SchoolID, group = SchoolID)) +\n  geom_point() +\n  geom_line() +\n  labs(title = \"Médias por Escola\",\n       x = \"\",\n       y = \"Valores das médias de THKS\") +\n  theme_minimal() +\n  theme(legend.position = \"right\")  # Posição da leg\n\n```\n\nObserve no gráfico que o efeito da intervenção é basicamente constante. Antes da intervenção a média de THKS era menor e após a intervenção a média aumentou em praticamente todas as escolas analisadas.\n\nVamos fazer o mesmo mas separando as médias por classes.\n\n### Média por classe\n\n```{r}\n# Instale o pacote ggplot2 se ainda não o tiver instalado\n# install.packages(\"ggplot2\")\n\n\n# Crie um novo dataframe para armazenar a média das notas por escola\nmedia_por_classe <- aggregate(cbind(PreTHKS, PosTHKS) ~ ClassID, data = dataset, FUN = mean)\n\n# Transforme os dados em formato longo (tidy)\nmedia_por_classe_long <- tidyr::pivot_longer(media_por_classe, cols = c(\"PreTHKS\", \"PosTHKS\"), names_to = \"tempo\", values_to = \"media\")\n\n# Crie um gráfico de dispersão com uma linha contínua conectando as médias das notas\nggplot(data = media_por_classe_long, aes(x = forcats::fct_rev(tempo), y = media, color = ClassID, group = ClassID)) +\n  geom_point() +\n  geom_line() +\n  labs(title = \"Médias por Classe\",\n       x = \"\",\n       y = \"Média de Notas\") +\n  #scale_color_manual(values = rainbow(length(top_50_escolas))) +  # Ajuste as cores manualmente\n  theme_minimal() +\n  theme(legend.position = \"none\")  # Posição da legenda\n\n```\n\nObservamos que, em alguns casos, a média de THKS diminui após a intervenção, enquanto em outros ocorre um aumento. A falta de um padrão claro sugere que a classe também desempenha um papel na resposta à intervenção, indicando a necessidade de utilizar modelos hierárquicos com fatores aleatórios nessa variável.\n\n### Média por Grupo\n\n```{r}\n# Instale o pacote ggplot2 se ainda não o tiver instalado\n# install.packages(\"ggplot2\")\nhead(dataset)\n\n# Crie um novo dataframe para armazenar a média das notas por escola\nmedia_por_grupo <- aggregate(cbind(PosTHKS, PreTHKS) ~ Group, data = dataset, FUN = mean)\n\n# Transforme os dados em formato longo (tidy)\nmedia_por_grupo_long <- tidyr::pivot_longer(media_por_grupo, cols = c(\"PreTHKS\", \"PosTHKS\"), names_to = \"tempo\", values_to = \"media\")\n\n# Crie um gráfico de dispersão com uma linha contínua conectando as médias das notas\nggplot(data = media_por_grupo_long, aes(x = forcats::fct_rev(tempo), y = media, color = Group, group = Group)) +\n  geom_point() +\n  geom_line() +\n  labs(title = \"Médias por Grupo\",\n       x = \"\",\n       y = \"Valores das médias de THKS\") +\n  theme_minimal() +\n  theme(legend.position = \"right\")  # Posição da leg\n\n```\n\nOs grupos também parecem ter um padrão constante de aumento na média de THKS após a intervenção, indicano que não há necessidade de colocar essa variável como efeito aleatório.\n\n## b) Efeitos fixos e aleatórios\n\n::: callout-note\n#### Exercício\n\nDentre os efeitos observados -- Grupo, Classe e Escola -- quais são efeitos fixos e aleatórios pelo menos do ponto de vista teórico?\n:::\n\nos gráficos são apenas uma das diversas maneiras de verificar a necessidade ou não de efeitos aleatórios. Mais a frente vamos ver outras métricas que podemos nos ajudar com a decisão.\n\nCom base nos gráficos anteriores, podemos inferir que a classe é um efeito aleatório, enquanto a escola e o grupo são efeitos fixos. Para seguir a abordagem prática exemplificada durante a aula no SPSS, iremos construir vários modelos considerando efeitos fixos e aleatórios. Posteriormente, compararemos os índices de aderência e os resultados obtidos, com o intuito de selecionar o modelo mais adequado para os nossos dados.\n\n## c) GLM univariado\n\n::: callout-note\n#### Exercício\n\nFaça um GLM univariado tendo o THKS pós como VD e os grupos, escolas e classes como variáveis independentes. Coloque as variáveis como efeitos fixos e aleatórios adequadamente conforme a questão anterior. Descreva os resultados encontrados.\n:::\n\nCaso queira repetir o modelo que o Altay apresentou no vídeo, execute o código abaixo. Assim como no SPSS, no R os valores serão calculados por muito tempo e o modelo não vai convergir.\n\n::: {.callout-caution collapse=\"true\"}\n#### Por conta e risco!\n\n`modelo1 <- lm(PosTHKS ~ Group * SchoolID * ClassID * PreTHKS, data=dataset)`\n:::\n\n## d) Componentes da variância e ICC\n\n::: callout-note\n#### Exercício\n\nUtilizando o \"Variance Components\", verifique se Classe e Escola podem ser considerados fatores aleatórios. Utilize o ICC (Coeficiente de Correlação Intraclasse) como critério para decidir.\n:::\n\nVamos utilizar a função `lmer()` do pacote `lme4` para criar nossos primeiro modelo com efeitos fixos e aleatórios **(modelo 1)**. Em seguida vamos extrair os componentes da variância dos resultados.\n\n```{r}\n#| echo: true\n#| message: false\n#| warning: false\n\nmodelo_1 = lmer(PosTHKS ~ 1 + Group * PreTHKS + # Efeitos fixos\n                  (1|SchoolID:ClassID) + # intercepto aleatório da classe aninhado na escola\n                  (1|SchoolID), # intercepto aleatório apenas da escola\n                data = dataset, \n                REML = TRUE) # Método de estimação dos parâmetros\n```\n\nImportante notar em nosso modelo que os efeitos fixos estão fora dos parênteses, ao passo que os efeitos aleatórios (SchooID e ClassID) estão contidos dentro dos parênteses. Essa estrutura informa à função lmer quais variáveis têm efeitos fixos e quais têm efeitos aleatórios.\n\nQuanto os métodos de estimação dos parâmetros, não deixe de ler a seção \"@sec-extras\"\n\nO primeiro passo para mostrar os componentes da variância é extrair os valores do modelo utilizando a função `VarCorr`. Vamos guardar a saída da função em um data-frame, tornando a visualização mais acessível. Em seguida, utilizaremos os estimadores de variância desejados no cálculo do ICC.\n\n```{r}\nvar_modelo_1 = as.data.frame(VarCorr(modelo_1))\nvar_modelo_1\n```\n\nOs valores que precisamos para calcular o ICC estão na coluna `vcov`.\n\nvamos agora armazenar os valores desejados em outras variáveis.\n\n```{r}\nvar_classe_1 = var_modelo_1$vcov[1] # classe\nvar_escola_1 = var_modelo_1$vcov[2] # school\nvar_erro_1 = var_modelo_1$vcov[3] # total\n\n```\n\nO que fizemos aqui foi acessar o data-frame (comp_var_modelo_1), indicar a coluna que queremos acessar O cifrão (`$vcoc`) e a linha em que se encontra o valor, indicada pelo número dentra das chaves `[]`.\n\nTudo o que precisamos fazer agora é calcular o ICC, que se dá pela seguinte fórmula:\n\n$$\nICC = \\frac{\\sigma^2_{\\text{entre grupos}}}{\\sigma^2_{\\text{entre grupos}} + \\sigma^2_{\\text{do erro}}}\n$$\n\n### ICC Escola (modelo 1)\n\nVamos primeiro calcular o ICC da Escola.\n\n```{r}\n\n# ICC Escola\nicc_escola_1 = var_escola_1 / (var_escola_1 + var_erro_1)\nround(icc_escola_1, 3)\n```\n\nArredondando o valor do cálculo temos que o valor do ICC da escola é de 0,023, ou de aproximadamente 2,3%. Se um valor de 5% fosse estabelecido para considerar uma variabilidade significativa entre os grupos, o ICC de 0,023 seria bastante baixo em relação a esse limiar.\n\n### ICC Classe (modelo 1)\n\nPara calcular o ICC da classe temos:\n\n```{r}\n\n# ICC Classe\nicc_class_1 = var_classe_1 / (var_classe_1 + var_erro_1)\nround(icc_class_1, 3)\n```\n\nAqui também temos um valor de ICC abaixo dos 5%, indicando que, por esse critério, a Classe também não deveria ser considerada como um fator aletaório.\n\nUma manipulação viável para avaliar o ICC exclusivamente a partir das variáveis que você considera como aleatórias é incluir apenas essas variáveis no modelo, excluindo todas as outras que tenham efeito fixo. Vamos refazer todos os passos anteriores, apenas mudando o modelo **(modelo 2)**.\n\n```{r}\nmodelo_2 = lmer(PosTHKS ~ 1 +\n                  (1|SchoolID:ClassID) +\n                  (1|SchoolID), \n                data = dataset, \n                REML = TRUE) # Método de estimação dos parâmetros\n```\n\n```{r}\nvar_modelo_2 = as.data.frame(VarCorr(modelo_2))\nvar_modelo_2\n```\n\n```{r}\nvar_classe_2 = var_modelo_2$vcov[1] # classe\nvar_escola_2 = var_modelo_2$vcov[2] # escola\nvar_erro_2 = var_modelo_2$vcov[3] # total\n\n```\n\n### ICC Escola (modelo 2)\n\nCalculando o ICC da escola para o modelo 2 temos\n\n```{r}\n# ICC escola\n\nicc_school_2 = var_escola_2 / (var_escola_2 + var_erro_2)\nround(icc_school_2, 3)\n```\n\nAgora temos que o ICC da escola é maior que 5%, indicando que a variável é uma boa candidata para ser designada tendo efeito aleatório.\n\n### ICC Classe (modelo 2)\n\n```{r}\n# ICC classe\n\nicc_class_2 = var_classe_2 / (var_classe_2 + var_erro_2)\nround(icc_class_2, 3)\n```\n\nJá a classe continua com um valor de ICC abaixo dos 5%\n\n### ICC com função\n\nPodemos utilizar a função `multilevel.icc` do pacote `misty` para não precisar calcular na mão o ICC. Digno de nota que a função não aceita efeitos fixos, portanto teremos **APENAS** o ICC do modelo com efeitos aleatórios. Além disso a função pode assumir 3 tipos:\n\n-   ICC(1) - Mostra quanto da variação ocorre entre os grupos (nível 2) e entre os grupos de grupos (nível 3), que é semelhante ao que calculamos na mão.\n\n```{r}\nmultilevel.icc(PosTHKS, # Variável dependente\n               data = dataset, # Banco de dados\n               cluster = c(\"SchoolID\", \"ClassID\")) # Ordem dos clusters importa. Primeiro o L3 e depois o L2\n```\n\n-   ICC(1b) - Representa a correlação esperada entre dois elementos escolhidos aleatoriamente no mesmo grupo.\n\n```{r}\nmultilevel.icc(PosTHKS, \n               data = dataset, \n               cluster = c(\"SchoolID\", \"ClassID\"),\n               type = \"1b\")\n```\n\n-   ICC(2) Indica quão confiáveis são as médias dos grupos (nível 2 e 3). Ou seja, o quão representativas são as médias dos grupos em relação às diferenças individuais dentro desses grupos.\n\n```{r}\nmultilevel.icc(PosTHKS, data = dataset, cluster = c(\"SchoolID\", \"ClassID\"),\ntype = \"2\")\n```\n\nNotem que a primeira fórmula apresenta resultado similar ao que calculamos na mão.\n\n::: callout-important\n#### Importante!\n\nNão existe um conceito fechado de como definir se uma variável deve ser considerada ou não como efeito aleatório. A teoria deve sempre prevalecer sobre os demais critérios.\n:::\n\nPelo critério teórico, vamos assumir que tanto escola quanto classe terão efeito aleatório em nosso modelo final.\n\n## e) Interpretando os resultados\n\n::: callout-note\n#### Exercício\n\nRealize um Modelo Misto Hierárquico (caso os fatores aleatórios sejam relevantes com base em d). Descreva os resultados adequadamente e verifique qual combinação de fatores aleatórios é a mais adequada para explicar a variação dos resultados do THKS (com base no ICC).\n:::\n\n### Verificando a referência do Grupo\n\nPara seguir os passos do vídeo feito pelo Altay no SPSS primeiro temos que ajustar o nível de referência da variável Grupo. No SPSS a referência é o grupo que não fez nada (Neither). Para verificar qual o nível de referência aqui no R vamos utilizar a função `levels()`.\n\n```{r}\nlevels(dataset$Group)\n```\n\nO nível de referência é sempre primeiro que aparece na lista, no caso \"Curriculum & TV\".\n\nVamos mudar para que a referência seja \"Neither\", utilizando a função relevel.\n\n```{r}\ndataset$Group <- relevel(dataset$Group, ref = \"Neither\")\nlevels(dataset$Group)\n```\n\nAgora sim podemos seguir com nossa análise.\n\n### Criando o modelo\n\nAo contrário do SPSS, não enfrentaremos problemas de convergência em nossos modelos se a matriz de covariância não for modificada. Para demonstrar que alterar a matriz de covariância não afeta significativamente os coeficientes, podemos criar dois modelos para verificação:\n\n-   a\\) modelo com matriz de covariância simétrica;\n\n-   b\\) modelo com matriz de covariância diagonal (padrão caso não definamos explicitamente a matriz).\n\nA função `lmer()` não oferece uma maneira direta de modificar a matriz de covariância. Portanto, da mesma forma que fizemos na Lista de Exercícios 3, vamos utilizar a função `lme()`.\n\n```{r}\n\n# Modelo a)\nmodelo_a = lme(\n  fixed = PosTHKS ~ 1 + PreTHKS + Group, \n  random =~ 1|SchoolID/ClassID,\n  correlation = corCompSymm(form = ~1|SchoolID/ClassID), # Aqui definimos a matriz simétrica\n  data = dataset, \n  method = \"REML\")\n\n# Armazenando os valores dos coeficientes do modelo a) em uma variável\ncoef_a = modelo_a$coefficients$fixed\n\n# Modelo b)\nmodelo_b = lme(\n  fixed = PosTHKS ~ 1 + PreTHKS + Group, \n  random =~ 1|SchoolID/ClassID,\n  data = dataset, \n  method = \"REML\") # Matriz diagonal por padrão\n\n# Armazenando os valores dos coeficientes do modelo b) em uma variável\ncoef_b = modelo_b$coefficients$fixed\n\n\n# Criar um dataframe\ndf_coeficientes <- data.frame(Modelo_a = coef_a,\n                              Modelo_b = coef_b)\ndf_coeficientes\n\n```\n\nPodemos observar que os valores mudam apenas depois da 3 casa após a vírgula. Portanto podemos construir os modelos sem alterar a matriz de covariância neste caso específico.\n\n<!-- Vamos continuar utilizando a função `lmer()`, mas caso precise alterar a matriz de variância do seu modelo, veja a resolução dos exercícios da lista 3 (@sec-lista-3). -->\n\nVamos ao modelo:\n\n```{r}\nmodelo_3 = lme(\n  fixed = PosTHKS ~ 1 + PreTHKS + Group, \n  random =~ 1|SchoolID/ClassID,\n  data = dataset, \n  method = \"REML\")\n\n# Escolhi utilizar o lme() por ele apresentar mais resultados na saída da função anova()\n```\n\n### ICC do modelo\n\nNão encontramos uma maneira fácil de mostrar o ICC para modelos de 3 níveis com variáveis independentes fixas. Por isso mostramos como calcular na mão o ICC anteriormente. Podemos acessar os valores de variância do modelo com a seguinte função:\n\n```{r}\nkable(VarCorr(modelo_3)) # O kable é só pra deixar com um visual melhor a saída.\n\n```\n\nAgora queremos acessar cada variância separadamente. Para isso executamos o scritp a seguir.\n\n```{r}\nvar_escola = VarCorr(modelo_3)[2] # Variancia da Escola\n\nvar_classe = VarCorr(modelo_3)[4] # Variancia da Classe\n\nvar_res = VarCorr(modelo_3)[5] # Variancia do resíduo\n```\n\nSe você tentar fazer contas com essas variáveis vai notar algo bem estranho\n\n```{r}\n#| echo: true\n#| eval: false\n#| message: false\n#| warning: true\n\nvar_classe + var_res\n```\n\nIsso acontece porque elas saíram como caracteres (símbolos, letras...) e não como números!\n\n```{r}\ntypeof(var_classe)\n```\n\nVamos resolver isso transformando elas para números\n\n```{r}\nvar_escola = as.numeric(var_escola)\nvar_classe = as.numeric(var_classe)\nvar_res = as.numeric(var_res)\n\n```\n\nAgora sim!\n\n```{r}\ntypeof(var_escola)\n```\n\nCalculando o ICC da Escola temos:\n\n```{r}\nvar_escola/(var_escola+var_res) #ICC da escola\n\n```\n\nICC da classe:\n\n```{r}\nvar_classe/(var_classe+var_res)\n```\n\n### Pressupostos do modelo\n\nComo já vimos, parte importante de analisar os modelos é verificar os pressupostos. Não entraremos em detalhes, vamos apenas vislumbrar quandos todos os pressupostos são atendidos! O melhor de tudo, usando apenas 3 palavras na linha de código, graças à função `check_model()`.\n\n```{r}\ncheck_model(modelo_3)\n```\n\nQue beleza, não? Resíduos normais, baixa colinearidade e ótima linearidade do modelo! Podemos interpretar os resultados com tranquilidade!\n\n### Resultados\n\nVamos verificar se o efeito do grupo é significante, que é a principal variável dependente do nosso modelo. Para isso podemos utilizar a função `anova()` que é muito versátil para diversas ocasiões.\n\n```{r}\nkable(anova(modelo_3)) #função kable apenas para deixar mais bonita a tabela\n\n```\n\nBoa! Descobrimos que o efeito do grupo é significativo. Agora precisamos saber entre quais grupos está a diferença e de quanto ela é.\n\nPara tanto vamos utilizar mais uma vez a função `summary()`.\n\n```{r}\nsummary(modelo_3)\n```\n\nComo vocês já podem ter percebido as saídas da função `summary()` no R não geram as saídas mais fáceis de interpretar, como podemos ver no exemplo abaixo.\n\nAgora que você enfrentou a busca nos detalhes desse fascinante output gerado pela função summary, é com satisfação que compartilhamos a boa notícia de que muitos desenvolvedores compartilham da sua experiência e criaram vários pacotes para aprimorar a visualização dos resultados. Ao longo dos exercícios, apresentaremos algumas abordagens para alcançar isso. No final da seção de modelos lineares, você encontrará um glossário que ajudará na geração de outputs mais amigáveis e formatados para publicações acadêmicas.\n\nPor hora, vamos compartilhar uma abordagem mais \"na mão\" para melhorar a visualização dos resultados, para caso algum pacote não atenda completamente às suas necessidades.\n\n```{r}\n# Resumo do modelo\n\nresumo_modelo <- summary(modelo_3)\n\n# Extração de estimadores, intervalos de confiança e p-valores\n\ncoeficientes <- resumo_modelo$coefficients$fixed # essa linha varia muito dependendo do modelo\nintervalos_confianca <- intervals(modelo_3, which = \"fixed\") # Função `confint()` pode ser utilizadas para outros modelos\np_valores <- resumo_modelo$tTable[, \"p-value\"]\n\n# Criar um data frame\n\nresultados_modelo <- data.frame(\n  Estimador = round(coeficientes, 3),\n  IC_Inf = round(intervalos_confianca$fixed[, 1], 3),\n  IC_Sup = round(intervalos_confianca$fixed[, 2], 3),\n  p = round(p_valores, 3)\n)\n\n# Apresentando os resultados\nkable(resultados_modelo)\n\n```\n\n------------------------------------------------------------------------\n\nMelhorou um pouco né? Achou muito trabalhoso??\n\nQue tal fazer tudo em uma linha de código e ainda com correção de Bonferroni!?\n\n```{r}\nemmeans(modelo_3, pairwise ~ Group, adjust = \"bonferroni\") # por padrão temos a correção de Tukey\n```\n\nOs valores estão negativos porque ajustamos o nível de referência da variável Group para \"Neither\". No resultado temos que \"Curriculum\" apresenta a maior média geral. Logo seria interessante deixá-lo como variável de referência, caso queira que seus estimadores fiquem positivo. Já vimos como fazer isso anteriormente!\n\nTente modificar a referência para \"Curriculum\", mas **CUIDADO!** Não se esqueça de criar o modelo novamente, caso contrário os resultados ficarão errados!\n\nPara acessar apenas os resultados de contraste podemos fazer o seguinte:\n\n```{r}\nemmeans(modelo_3, pairwise ~ Group, adjust = \"bonferroni\")$contrasts\n```\n\n## Extras! {#sec-extras}\n\n### Métodos de estimação dos parâmetros do modelo\n\nO REML (Residual Maximum Likelihood) e o ML (Maximum Likelihood) são duas abordagens distintas para a estimação de parâmetros em modelos de regressão linear mista (ou modelos hierárquicos). Ambas são baseadas no método da máxima verossimilhança, mas diferem na maneira como tratam os graus de liberdade.\n\n**Maximum Likelihood (ML):**\n\nNa abordagem ML, o foco é maximizar a verossimilhança do modelo, considerando tanto os efeitos fixos quanto os efeitos aleatórios. O ML leva em conta todos os parâmetros do modelo para maximizar a probabilidade de observar os dados dados os parâmetros. É mais adequado quando o interesse principal é fazer inferências sobre os parâmetros fixos do modelo.\n\n**Residual Maximum Likelihood (REML):**\n\nA abordagem REML é uma variação do ML que remove os efeitos fixos do modelo antes de calcular a verossimilhança. O REML estima a verossimilhança condicional dos efeitos aleatórios, removendo a contribuição dos efeitos fixos. Ele tende a ser mais eficiente na estimação dos efeitos aleatórios, especialmente em amostras pequenas, e fornece estimativas menos enviesadas para a variância dos efeitos aleatórios. O REML é frequentemente preferido quando o foco está na estimação dos parâmetros aleatórios e quando a inferência sobre os parâmetros fixos não é o objetivo principal.\n\n### Extraindo valores de summary\n\nPodemos extrair diversos valores individualmente da função `summary()`.\n\n```{r}\n#| echo: false\n#| message: false\n#| warning: false\n#| include: false\nsummary(modelo_3)$coef # coeficientes para cada observação (linha)\nsummary(modelo_3)$sigma # desvio padrão residual\nsummary(modelo_3)$logLik # valor numérico que representa a log-verossimilhança do modelo\nsummary(modelo_3)$AIC # valor de AIC do modelo\nsummary(modelo_3)$BIC # valor de BIC do modelo\n```\n\n### Tamanho da classe importa?\n\n```{r}\ntheme_set(theme_bw(base_size = 7, base_family = \"\")) \n\nggplot(data = dataset, aes(x = Tamanho_Classe, y=PosTHKS))+\n  facet_grid(~SchoolID)+\n  coord_cartesian(ylim=c(0,30))+\n  geom_point()+\n  geom_smooth(method = \"lm\", se = TRUE)+\n  xlab(\"Tamanho da Classe\")+ylab(\"PosTHKS\")+\n  theme(legend.position = \"top\")\n\n\n```\n\n```{r}\nPlot.Means<-dataset %>% group_by(SchoolID) %>%  \n  dplyr::summarize(PosTHKSM = mean(PosTHKS, na.rm=TRUE),\n                   Tamanho_CLasseM=mean(Tamanho_Classe, na.rm=TRUE))\n\n\n\nggplot(data = Plot.Means, aes(x = reorder(SchoolID, -PosTHKSM), y=PosTHKSM))+\n  geom_point(aes(size = Tamanho_CLasseM))+\n  xlab(\"\")+ylab(\"PosTHKS\")+\n  theme_bw()+\n  theme(legend.position = \"top\")\n\n```\n\n### Comparando modelos\n\nPodemos comparar diversos modelos utilizando a função `model.comparison()` do pacote `flexplot`.\n\n```{r}\nmodel.comparison(modelo_1, modelo_2)\n\n# O modelo 1 apresenta melhores resultados\n```\n\n### Plot do modelo\n\nCriando um gráfico com os coeficientes gerados pelo modelo.\n\n```{r}\n# Com a correção de Bonferroni\nresults_modelo_3 = emmeans(modelo_3, pairwise ~ Group, adjust = \"bonferroni\")\n```\n\n```{r}\nggplot(as.data.frame(results_modelo_3$emmeans), aes(x = Group, y = emmean, color = Group)) +\n  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2, position = position_dodge(0.8)) +\n  geom_point(position = position_dodge(0.8), size = 3) +\n  labs(title = \"Distribuição normal\",\n       x = \"Tratamento\",\n       y = \"THKS\") +\n  theme_minimal() +\n  theme(legend.position = \"none\") \n\n```\n\n### Função para calcular o ICC\n\nCaso você queira calcular o ICC para diferentes modelos de 3 níveis, sugiro criar uma função que faça o trabalho repetitivo ao invés de ficar calculando tudo sempre na mão.\n\n::: callout-important\n## Importante\n\nFunciona apenas para modelos gerados pela função `lme()`.\n:::\n\n```{r}\n# Criando minha própria função\n\nicc_lme_3nv = function(modelo) {\n  # Extração da variância entre grupos e total\n  var_escola = as.numeric(VarCorr(modelo)[2])\n  var_classe = as.numeric(VarCorr(modelo)[4])\n  var_total = as.numeric(VarCorr(modelo)[5])\n\n  # Cálculo do ICC\n  icc_escola = var_escola/(var_escola+var_res)\n  icc_classe = var_classe/(var_classe+var_res)\n  \n  # Retorna o valor do ICC \n  return(list(\"ICC-Escola\" = icc_escola, \"ICC-Classe\" = icc_classe))\n}\n\n# Uso\n# icc_lme_3nv(modelo) - basta substitui \"modelo\" pelo nome da variável que você escolheu para salvar seu modelo.\n```\n\n## Observações\n\nTreine criar mais modelos multinível, inclusive com apenas 2 níveis. Inclusive, se for utilzar a função `lmer()`, MUITO CUIDADO!\n\nEste modelo:\n\n```{r}\nmodelo_5b = lmer(PosTHKS ~ 1 + Group +\n                   (1|SchoolID:ClassID),\n                 dataset,\n                 REML = TRUE)\n```\n\nÉ diferente deste modelo:\n\n```{r}\nmodelo_5b = lmer(PosTHKS ~ 1 + Group +\n                   (1|SchoolID) + # Escola como efeito aleatório\n                   (1|SchoolID:ClassID), # Classe como efeito aleatório\n                 dataset,\n                 REML = TRUE)\n```\n\nCom a função `lmer()` precisamos indicar no modelo que queremos Escola e Classe como efeito aleatórios em linhas separadas!\n\n## Lista 4 resolvida no SPSS\n\n{{< video https://www.youtube.com/watch?v=_1lUvEu8M9c title=’ HGMM - Hierarchical Generalized Mixed Models - Aula Prática #4 (SPSS)’ >}}\n\n## Referências\n\nhttps://lmudge13.github.io/sample_code/mixed_effects.html \\# Tabelas e gráficos de modelos lme\n\nhttps://rpsychologist.com/r-guide-longitudinal-lme-lmer#three-level-models\n\nhttps://search.r-project.org/CRAN/refmans/misty/html/multilevel.icc.html\n\nhttps://www.rdocumentation.org/packages/psychometric/versions/2.4/topics/ICC.lme\n\nhttps://www.alexanderdemos.org/Mixed5.html\n\nhttps://cran.r-project.org/web/packages/rempsyc/vignettes/assumptions.html#categorical-predictors \\# pressupostos dos modelos com variáveis categóricas como preditoras.\n\n## Versões dos pacotes\n\n```{r}\nreport(sessionInfo())\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"lista_4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.55","bibliography":["references.bib"],"number-depth":2,"editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"lista_4.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"number-depth":2,"editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}